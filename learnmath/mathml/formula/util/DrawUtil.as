/*-------------------------------------------------------------	Created by: Ionel Alexandru 	Mail: ionel.alexandru@gmail.com	Site: www.learn-math.info---------------------------------------------------------------*/import flash.geom.*;class learnmath.mathml.formula.util.DrawUtil{			public static function drawOval(graph:MovieClip, x:Number, y:Number, radius:Number, yRadius:Number) {		// ==============		// mc.drawOval() - by Ric Ewing (ric@formequalsfunction.com) - version 1.1 - 4.7.2002		// 		// x, y = center of oval		// radius = radius of oval. If [optional] yRadius is defined, r is the x radius.		// yRadius = [optional] y radius of oval.		// ==============		// init variables		var theta, xrCtrl, yrCtrl, angle, angleMid, px, py, cx, cy;		// if only yRadius is undefined, yRadius = radius		if (yRadius == undefined) {			yRadius = radius;		}		// covert 45 degrees to radians for our calculations		theta = Math.PI/4;		// calculate the distance for the control point		xrCtrl = radius/Math.cos(theta/2);		yrCtrl = yRadius/Math.cos(theta/2);		// start on the right side of the circle		angle = 0;		graph.moveTo(x+radius, y);		// this loop draws the circle in 8 segments		for (var i = 0; i<8; i++) {			// increment our angles			angle += theta;			angleMid = angle-(theta/2);			// calculate our control point			cx = x+Math.cos(angleMid)*xrCtrl;			cy = y+Math.sin(angleMid)*yrCtrl;			// calculate our end point			px = x+Math.cos(angle)*radius;			py = y+Math.sin(angle)*yRadius;			// draw the circle segment			graph.curveTo(cx, cy, px, py);		}	}		public static function drawArc(graph:MovieClip, x:Number, y:Number, radius:Number, arc:Number, startAngle:Number, yRadius:Number) {		// ==============		// mc.drawArc() - by Ric Ewing (ric@formequalsfunction.com) - version 1.5 - 4.7.2002		// 		// x, y = This must be the current pen position... other values will look bad		// radius = radius of Arc. If [optional] yRadius is defined, then r is the x radius		// arc = sweep of the arc. Negative values draw clockwise.		// startAngle = starting angle in degrees.		// yRadius = [optional] y radius of arc. Thanks to Robert Penner for the idea.		// ==============		// Thanks to: Robert Penner, Eric Mueller and Michael Hurwicz for their contributions.		// ==============		// if yRadius is undefined, yRadius = radius		if (yRadius == undefined) {			yRadius = radius;		}		// Init vars		var segAngle, theta, angle, angleMid, segs, ax, ay, bx, by, cx, cy;		// no sense in drawing more than is needed :)		if (Math.abs(arc)>360) {			arc = 360;		}		// Flash uses 8 segments per circle, to match that, we draw in a maximum		// of 45 degree segments. First we calculate how many segments are needed		// for our arc.		segs = Math.ceil(Math.abs(arc)/45);		// Now calculate the sweep of each segment		segAngle = arc/segs;		// The math requires radians rather than degrees. To convert from degrees		// use the formula (degrees/180)*Math.PI to get radians. 		theta = -(segAngle/180)*Math.PI;		// convert angle startAngle to radians		angle = -(startAngle/180)*Math.PI;		// find our starting points (ax,ay) relative to the secified x,y		ax = x-Math.cos(angle)*radius;		ay = y-Math.sin(angle)*yRadius;		// if our arc is larger than 45 degrees, draw as 45 degree segments		// so that we match Flash's native circle routines.				if (segs>0) {			// Loop for drawing arc segments			graph.moveTo(ax+Math.cos(angle)*radius, ay+Math.sin(angle)*yRadius);			for (var i = 0; i<segs; i++) {				// increment our angle				angle += theta;				// find the angle halfway between the last angle and the new				angleMid = angle-(theta/2);				// calculate our end point				bx = ax+Math.cos(angle)*radius;				by = ay+Math.sin(angle)*yRadius;				// calculate our control point				cx = ax+Math.cos(angleMid)*(radius/Math.cos(theta/2));				cy = ay+Math.sin(angleMid)*(yRadius/Math.cos(theta/2));				// draw the arc segment								graph.curveTo(cx, cy, bx, by);			}		}		// In the native draw methods the user must specify the end point		// which means that they always know where they are ending at, but		// here the endpoint is unknown unless the user calculates it on their 		// own. Lets be nice and let save them the hassle by passing it back. 		return {x:bx, y:by};	}}